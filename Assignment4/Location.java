/*
  Name: Bastien Gliech
  CIS 421 Artificial Intelligence
  Assignment: 4 - A* Algorithm
  Due: March, 2018
  Worked with Alexander Olesen on implementation ideas
*/

import java.util.*;

// Location Class - serves as nodes of the graph generated by map
//
// Holds the majority of node specific information
public class Location implements Comparable<Location>{

  // fields
  public String name;
  public int hScore, fScore, gScore;
  public Queue<Location> history;
  public Set<Road> roads;
  public boolean unvisited;

  /** Constructor
   * 
   * @param: none
   * @pre:   none
   * @post:  Location object is constructed 
   */
  public Location(){
    roads = new HashSet<Road>();
    history = new LinkedList<Location>();
    unvisited = true;
  }

  /** Checks if two locations are similar if they have the same name
   *
   * @param: Location l -- Location to be tested against
   * @pre:   both locations have a name assigned
   * @post:  returns whether they are equal or not
   */
  public boolean equals(Location l){
    return l.name.equals(this.name);
  }

  /** Compares this node's fScore with the specified node's fScore
   *
   * @param: Location other -- Location to be compared to
   * @pre: both locations have a calculated fScore
   * @post: two objects are compared by their fScore
   */
  public int compareTo(Location other){

    // this heuristic is greater than other heuristic
    if (this.fScore > other.fScore){
      return 1;

    // this heuristic is less than other heuristic
    } else if (this.fScore < other.fScore){
      return -1;

    // heuristics are the same
    } else {
      return 0;
    }
  }

  /** Calculates the gScore of this location
   *
   * @param: Road r -- Road being travelled from
   * @pre:   r.cost and other Location's gScore are properly defined
   * @post:  gScore is calculated and stored
   */
  public void calculategScore(Road r){
    gScore = r.cross(this).gScore + r.cost;
  }

  /** Calculates the fScore of this location
   *
   * @param: none
   * @pre:   hScore and gScore are properly defined
   * @post:  fScore is calculated and stored
   */
  public void calculatefScore(){
    fScore =  gScore + hScore;
  }

  /** Returns a copy of this object
   *
   * @param: none
   * @pre:   all of this Location's fields are instanciated
   * @post:  copy of this Location is returned
   */
  public Location copyOf(){
    Location l = new Location();
    l.name = name;
    l.hScore = hScore;
    l.fScore = fScore;
    l.gScore = gScore;
    for (Road r : roads){
      l.roads.add(r);
    }
    for (Location l1 : history){
      l.history.add(l1);
    }
    return l;
  }
}